# ServarrDock: Media acquisition and automation pipeline (VPN + *arr services).
# This compose file contains high-churn services: VPN gateway, download clients, indexer aggregator, and automation tools.
# Design notes:
# - Only the services that must reach the public Internet via VPN run in Gluetun's network namespace.
# - Media managers (*arr, Bazarr, LazyLibrarian) sit on the shared bridge (media-net) and use Docker DNS for inter-service calls.
# - User access is via Traefik on HTTPS (443/tcp) using host-based routing under *.${DOMAIN}.

name: pipeline # Compose project name for this stack

services:
### NETWORK SERVICES
  gluetun: # VPN gateway container used as a shared network namespace for selected services
    container_name: gluetun
    image: qmcgaw/gluetun:v3.34 # Gluetun image (pinned version as a workaround)
    devices: # Host devices passed through to the container
      - /dev/net/tun:/dev/net/tun # TUN device required for VPN tunnelling
    cap_add: # Linux capabilities granted to the container
      - NET_ADMIN # Required so Gluetun can manage firewall and routing
    environment: # Environment variables controlling VPN behaviour
      - VPN_SERVICE_PROVIDER=${VPNSP} # VPN provider identifier (Gluetun)
      - OPENVPN_USER=${OPENVPN_USER} # OpenVPN username
      - OPENVPN_PASSWORD=${OPENVPN_PASSWORD} # OpenVPN password
      - SERVER_COUNTRIES=${VPN_COUNTRY} # VPN server country selection
      - TZ=${TZ} # Time zone
      # Enable Gluetun's built-in HTTP proxy
      - HTTPPROXY=on           # Turn on the internal HTTP proxy
      - HTTPPROXY_LISTENING_ADDRESS=:8888 # Listen on port 8888 for HTTP proxy clients
      # Allow inbound ports through Gluetun's firewall (proxy + download clients)
      - FIREWALL_INPUT_PORTS=8080,8090,8888,1080
    volumes: # Persistent configuration storage
      - ${CONFIG_PATH}/gluetun:/gluetun # Gluetun configuration directory
    networks: # Network attachments for this container
      media-net: # Attach to the shared media/control-plane bridge for Traefik + Docker DNS
    labels: # Traefik routing for services running inside the Gluetun namespace
      - traefik.enable=true # Enable Traefik for this container
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching Gluetun namespace services

      # SABnzbd labels
      - traefik.http.routers.sabnzbd.rule=Host(`${DOMAIN}`) && PathPrefix(`/sabnzbd`) # SABnzbd router rule (path-based)
      - traefik.http.routers.sabnzbd.entrypoints=websecure # SABnzbd router entrypoint (HTTPS)
      - traefik.http.routers.sabnzbd.tls=true # Enable TLS for SABnzbd
      - traefik.http.routers.sabnzbd.tls.certresolver=myresolver # SABnzbd certificate resolver
      - traefik.http.routers.sabnzbd.service=sabnzbd-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.sabnzbd.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to SABnzbd
      - traefik.http.services.sabnzbd-svc.loadbalancer.server.port=8080 # SABnzbd internal port inside Gluetun namespace

      # qBittorrent labels
      - traefik.enable=true # Enable Traefik for this container
      - traefik.http.routers.qbittorrent.service=qbittorrent-service # Define the service name
      - traefik.http.routers.qbittorrent.entrypoints=websecure # Use the websecure entrypoint
      - traefik.http.routers.qbittorrent.rule=Host(`${DOMAIN}`) && PathPrefix(`/qbittorrent`) # Define the HTTP router rule based on the domain
      - traefik.http.routers.qbittorrent.tls=true # Enable TLS
      - traefik.http.routers.qbittorrent.tls.certresolver=myresolver # Use the defined certificate resolver
      - traefik.http.routers.qbittorrent.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting and Authelia middleware
      - traefik.http.middlewares.qbittorrent-redirect.redirectregex.regex=^(.*)/qbittorrent$$ # Redirect to add trailing slash
      - traefik.http.middlewares.qbittorrent-redirect.redirectregex.replacement=$$1/qbittorrent/ # Redirect replacement pattern
      - traefik.http.middlewares.qbittorrent-strip.stripprefix.prefixes=/qbittorrent/ # Strip /qbittorrent/ prefix
      - traefik.http.middlewares.qbittorrent-headers.headers.customrequestheaders.X-Frame-Options=SAMEORIGIN # Set X-Frame-Options header
      - traefik.http.middlewares.qbittorrent-headers.headers.customrequestheaders.Referer= # Set Referer header
      - traefik.http.middlewares.qbittorrent-headers.headers.customrequestheaders.Origin= # Set Origin header
      - traefik.http.routers.qbittorrent.middlewares=qbittorrent-redirect,qbittorrent-strip,qbittorrent-headers # Apply middlewares to the router
      - traefik.http.services.qbittorrent-service.loadbalancer.server.port=8090 # Define the service port
      - traefik.http.services.qbittorrent-service.loadbalancer.passhostheader=false # Disable passing the host header
    restart: unless-stopped # Restart policy

### DOWNLOAD CLIENTS (VPN-BOUND)
  sabnzbd: # Usenet downloader (runs inside Gluetun VPN namespace)
    container_name: sabnzbd
    image: ghcr.io/linuxserver/sabnzbd # LinuxServer.io SABnzbd image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun starts before SABnzbd
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
      - SABNZBD_HOST=0.0.0.0 # Bind SABnzbd to all interfaces in the namespace
    volumes: # Persistent storage and media access
      - ${CONFIG_PATH}/sabnzbd:/config # SABnzbd configuration directory
      - ${MEDIA_PATH}:/media # Media directory (downloads and library paths)
    network_mode: "service:gluetun" # Share Gluetun network namespace (forces SAB traffic via VPN)
    restart: unless-stopped # Restart policy

  qbittorrent:  # A lightweight and feature-rich BitTorrent client that enables you to download torrents and manage your torrent files.
    container_name: qbittorrent
    image: ghcr.io/linuxserver/qbittorrent # The qBittorrent Docker image from the LinuxServer.io repository
    depends_on:
      - gluetun # Ensure Gluetun starts before qBittorrent
    environment: # Environment variables for the container
      - PUID=${PUID} # User ID for the container
      - PGID=${PGID} # Group ID for the container
      - TZ=${TZ} # Time zone
      - WEBUI_PORT=8090 # Port for the qBittorrent web interface
    volumes: # Bind mount host volumes to the container
      - ${CONFIG_PATH}/qbittorrent:/config # Mount the qBittorrent configuration directory
      - ${MEDIA_PATH}:/media # Mount the media directory for storing downloaded files
    network_mode: "service:gluetun" # Use the Gluetun container's network, routing qBittorrent traffic through the VPN tunnel
    restart: unless-stopped # Restart the container unless it is explicitly stopped

### INDEXER AGGREGATOR (VPN-BOUND)
  prowlarr: # Indexer manager that brokers indexers for Sonarr/Radarr/Lidarr
    container_name: prowlarr
    image: ghcr.io/linuxserver/prowlarr:latest # LinuxServer.io Prowlarr image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun starts before Prowlarr
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
    volumes: # Persistent configuration storage
      - ${CONFIG_PATH}/prowlarr:/config # Prowlarr configuration directory
    networks: # Network attachments for this container
      media-net: # Attach to the shared media/control-plane bridge for Traefik + Docker DNS
    labels:
      - traefik.enable=true # Enable Traefik for this container
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching Prowlarr 
      - traefik.http.routers.prowlarr.rule=Host(`${DOMAIN}`) && PathPrefix(`/prowlarr`) # Prowlarr router rule (path-based)
      - traefik.http.routers.prowlarr.entrypoints=websecure # Prowlarr router entrypoint (HTTPS)
      - traefik.http.routers.prowlarr.tls=true # Enable TLS for Prowlarr
      - traefik.http.routers.prowlarr.tls.certresolver=myresolver # Prowlarr certificate resolver
      - traefik.http.routers.prowlarr.service=prowlarr-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.prowlarr.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to Prowlarr
      - traefik.http.services.prowlarr-svc.loadbalancer.server.port=9696 #  Prowlarr internal port
    restart: unless-stopped # Restart policy

### MEDIA MANAGERS (NON-VPN, BRIDGE + DOCKER DNS)
  radarr: # Movie library manager and automation service
    container_name: radarr
    image: ghcr.io/linuxserver/radarr # LinuxServer.io Radarr image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun (and thus download clients) is up before Radarr starts
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
    volumes: # Persistent configuration and media access
      - ${CONFIG_PATH}/radarr:/config # Radarr configuration directory
      - ${MEDIA_PATH}:/media # Media directory (downloads and library paths)
    networks: # Network attachments
      - media-net # Shared media/control-plane bridge (Traefik + Docker DNS)
    labels: # Traefik routing labels (path-based)
      - traefik.enable=true # Enable Traefik for Radarr
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching Radarr
      - traefik.http.routers.radarr.rule=Host(`${DOMAIN}`) && PathPrefix(`/radarr`) # Radarr router rule (path-based)
      - traefik.http.routers.radarr.entrypoints=websecure # Radarr router entrypoint (HTTPS)
      - traefik.http.routers.radarr.tls=true # Enable TLS for Radarr
      - traefik.http.routers.radarr.tls.certresolver=myresolver # Radarr certificate resolver
      - traefik.http.routers.radarr.service=radarr-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.radarr.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to Radarr
      - traefik.http.services.radarr-svc.loadbalancer.server.port=7878 # Radarr internal port
    restart: unless-stopped # Restart policy

  sonarr: # TV library manager and automation service
    container_name: sonarr
    image: ghcr.io/linuxserver/sonarr # LinuxServer.io Sonarr image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun (and thus download clients) is up before Sonarr starts
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
    volumes: # Persistent configuration and media access
      - ${CONFIG_PATH}/sonarr:/config # Sonarr configuration directory
      - ${MEDIA_PATH}:/media # Media directory (downloads and library paths)
    networks: # Network attachments
      - media-net # Shared media/control-plane bridge (Traefik + Docker DNS)
    labels: # Traefik routing labels (path-based)
      - traefik.enable=true # Enable Traefik for Sonarr
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching Sonarr
      - traefik.http.routers.sonarr.rule=Host(`${DOMAIN}`) && PathPrefix(`/sonarr`) # Sonarr router rule (path-based)
      - traefik.http.routers.sonarr.entrypoints=websecure # Sonarr router entrypoint (HTTPS)
      - traefik.http.routers.sonarr.tls=true # Enable TLS for Sonarr
      - traefik.http.routers.sonarr.tls.certresolver=myresolver # Sonarr certificate resolver
      - traefik.http.routers.sonarr.service=sonarr-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.sonarr.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to Sonarr
      - traefik.http.services.sonarr-svc.loadbalancer.server.port=8989 # Sonarr internal port
    restart: unless-stopped # Restart policy

  lidarr: # Music library manager and automation service
    container_name: lidarr
    image: ghcr.io/linuxserver/lidarr # LinuxServer.io Lidarr image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun (and thus download clients) is up before Lidarr starts
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
    volumes: # Persistent configuration and media access
      - ${CONFIG_PATH}/lidarr:/config # Lidarr configuration directory
      - ${MEDIA_PATH}:/media # Media directory (downloads and library paths)
    networks: # Network attachments
      - media-net # Shared media/control-plane bridge (Traefik + Docker DNS)
    labels: # Traefik routing labels (path-based)
      - traefik.enable=true # Enable Traefik for Lidarr
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching Lidarr
      - traefik.http.routers.lidarr.rule=Host(`${DOMAIN}`) && PathPrefix(`/lidarr`) # Lidarr router rule (path-based)
      - traefik.http.routers.lidarr.entrypoints=websecure # Lidarr router entrypoint (HTTPS)
      - traefik.http.routers.lidarr.tls=true # Enable TLS for Lidarr
      - traefik.http.routers.lidarr.tls.certresolver=myresolver # Lidarr certificate resolver
      - traefik.http.routers.lidarr.service=lidarr-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.lidarr.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to Lidarr
      - traefik.http.services.lidarr-svc.loadbalancer.server.port=8686 # Lidarr internal port
    restart: unless-stopped # Restart policy

  lazylibrarian: # Book, magazine, and audiobook manager
    container_name: lazylibrarian
    image: lscr.io/linuxserver/lazylibrarian:latest # LinuxServer.io LazyLibrarian image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun (and thus download clients) is up before LazyLibrarian starts
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
    volumes: # Persistent configuration and media access
      - ${CONFIG_PATH}/lazylibrarian:/config # LazyLibrarian configuration directory
      - ${MEDIA_PATH}:/media # Media directory (downloads and library paths)
    networks: # Network attachments
      - media-net # Shared media/control-plane bridge (Traefik + Docker DNS)
    labels: # Traefik routing labels (path-based)
      - traefik.enable=true # Enable Traefik for LazyLibrarian
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching LazyLibrarian
      - traefik.http.routers.lazylibrarian.rule=Host(`${DOMAIN}`) && PathPrefix(`/lazylibrarian`) # LazyLibrarian router rule (path-based)
      - traefik.http.routers.lazylibrarian.entrypoints=websecure # LazyLibrarian router entrypoint (HTTPS)
      - traefik.http.routers.lazylibrarian.tls=true # Enable TLS for LazyLibrarian
      - traefik.http.routers.lazylibrarian.tls.certresolver=myresolver # LazyLibrarian certificate resolver
      - traefik.http.routers.lazylibrarian.service=lazylibrarian-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.lazylibrarian.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to LazyLibrarian
      - traefik.http.services.lazylibrarian-svc.loadbalancer.server.port=5299 # LazyLibrarian internal port
    restart: unless-stopped # Restart policy

  bazarr: # Subtitle manager for Sonarr and Radarr
    container_name: bazarr
    image: ghcr.io/linuxserver/bazarr # LinuxServer.io Bazarr image
    depends_on: # Startup ordering
      - gluetun # Ensure Gluetun (and thus download clients) is up before Bazarr starts
    environment: # Container runtime configuration
      - PUID=${PUID} # User ID for file ownership
      - PGID=${PGID} # Group ID for file ownership
      - TZ=${TZ} # Time zone
    volumes: # Persistent configuration and media access
      - ${CONFIG_PATH}/bazarr:/config # Bazarr configuration directory
      - ${MEDIA_PATH}:/media # Media directory (downloads and library paths)
    networks: # Network attachments
      - media-net # Shared media/control-plane bridge (Traefik + Docker DNS)
    labels: # Traefik routing labels (path-based)
      - traefik.enable=true # Enable Traefik for Bazarr
      - traefik.docker.network=media-net # Force Traefik to use media-net when reaching Bazarr
      - traefik.http.routers.bazarr.rule=Host(`${DOMAIN}`) && PathPrefix(`/bazarr`) # Bazarr router rule (path-based)
      - traefik.http.routers.bazarr.entrypoints=websecure # Bazarr router entrypoint (HTTPS)
      - traefik.http.routers.bazarr.tls=true # Enable TLS for Bazarr
      - traefik.http.routers.bazarr.tls.certresolver=myresolver # Bazarr certificate resolver
      - traefik.http.routers.bazarr.service=bazarr-svc # Explicitly bind router to service name (avoids ambiguity)
      - traefik.http.routers.bazarr.middlewares=rateLimitMiddleware@file,authelia@file # Apply rate limiting + Authelia to Bazarr
      - traefik.http.services.bazarr-svc.loadbalancer.server.port=6767 # Bazarr internal port
    restart: unless-stopped # Restart policy

networks: # External networks created/anchored by the infrastructure stack
  my-network: # General-purpose shared bridge (legacy / non-media stacks)
    external: true # Use the existing external network
  media-net: # Shared media/control-plane bridge for edge + media stacks (Docker DNS)
    external: true # Use the existing external network
